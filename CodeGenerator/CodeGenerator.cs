using System;
using System.IO;
using System.Text;
using System.Reflection;
using ProtocolBuffers;

namespace ProtocolBuffers
{
	public static class CodeGenerator
	{
		/// <summary>
		/// Generate code for reading and writing protocol buffer messages
		/// </summary>
		public static void Save (Proto p, string nameSpace, string csPath)
		{
			
			using (TextWriter codeWriter = new StreamWriter(csPath, false, Encoding.UTF8)) {
				codeWriter.WriteLine (@"//
//	You may customize this code as you like
//	Report bugs to: https://silentorbit.com/protobuf-csharpgen/
//
//	Generated by ProtocolBuffer
//	- a pure c# code generation implementation of protocol buffers
//

using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using ProtocolBuffers;

namespace " + nameSpace + "\n{\n");
				
				foreach (Message m in p.Messages)
					codeWriter.WriteLine (Indent (1, GenerateClass (m)));
				
				codeWriter.WriteLine ("}");
			}
			
			string ext = Path.GetExtension(csPath);
			string backendPath = csPath.Substring(0, csPath.Length - ext.Length) + ".Backend" + ext;
			
			using (TextWriter codeWriter = new StreamWriter(backendPath, false, Encoding.UTF8)) {
				codeWriter.WriteLine (@"//
//	This is the backend code for reading and writing
//	Report bugs to: https://silentorbit.com/protobuf-csharpgen/
//
//	Generated by ProtocolBuffer
//	- a pure c# code generation implementation of protocol buffers
//

using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using ProtocolBuffers;

namespace " + nameSpace + "\n{\n");
				
				foreach (Message m in p.Messages)
					codeWriter.WriteLine (Indent (1, GenerateClassBackend (m)));
				
				codeWriter.WriteLine ("}");
			}
				
			string libPath = Path.Combine (Path.GetDirectoryName (csPath), "ProtocolParser.cs");
			using (TextWriter codeWriter = new StreamWriter(libPath, false, Encoding.UTF8)) {
				ReadCode (codeWriter, "ProtocolParser", true);
				ReadCode (codeWriter, "ProtocolParserFixed", false);
				ReadCode (codeWriter, "ProtocolParserKey", false);
				ReadCode (codeWriter, "ProtocolParserVarInt", false);
			}
		}
		
		/// <summary>
		/// Read c# code from sourcePath and write it on code without the initial using statements.
		/// </summary>
		private static void ReadCode (TextWriter code, string name, bool includeUsing)
		{
			code.WriteLine ("#region " + name);
			
			using (TextReader tr = new StreamReader(Assembly.GetExecutingAssembly ().GetManifestResourceStream (name), Encoding.UTF8)) {
				while (true) {
					string line = tr.ReadLine ();
					if (line == null)
						break;
					if (includeUsing == false && line.StartsWith ("using"))
						continue;
					
					code.WriteLine (line);
				}
			}
			code.WriteLine ("#endregion");
		}
		
		static string GenerateInterface (Message m)
		{
			string prop = "";
			foreach (Field f in m.Fields) {
				if (f.Deprecated)
					prop += "[Obsolete]\n";
				prop += f.CSType + " " + f.Name + " { get; set; }\n";
			}
			string code = "";
			code += "public interface I" + m.Name + "\n";
			code += "{\n";
			code += Indent (prop);
			code += "}\n";
			return code;
		}

		static string GenerateClass (Message m)
		{
			//Enums
			string enums = "";
			foreach (MessageEnum me in m.Enums) {
				enums += "public enum " + me.Name + "\n";
				enums += "{\n";
				foreach (var epair in me.Enums)
					enums += "	" + epair.Key + " = " + epair.Value + ",\n";
				enums += "}\n";
			}
			
			//Properties
			string properties = "";
			foreach (Field f in m.Fields) {
				properties += "public " + f.CSType + " " + f.Name + " { get; set; }\n";
			}
			
			//Constructor with default values
			string constructor = "public " + m.Name + "()\n";
			constructor += "{\n";
			foreach (Field f in m.Fields) {
				if (f.Rule == Rules.Repeated)
					constructor += "	this." + f.Name + " = new " + f.CSType + "();\n";
				else if (f.Default != null)
					constructor += "	this." + f.Name + " = " + f.Default + ";\n";
				else if (f.Rule == Rules.Optional) {
					if (f.ProtoType == ProtoTypes.Enum) {
						//the default value is the first value listed in the enum's type definition
						foreach (var kvp in f.ProtoTypeEnum.Enums) {
							constructor += "	this." + f.Name + " = " + kvp.Key + ";\n";
							break;
						}
					}
					if (f.ProtoType == ProtoTypes.String) {
						constructor += "	this." + f.Name + " = \"\";\n";
					}
				}
			}
			constructor += "}\n";

			//Default class
			string code = "";
			code += "public partial class " + m.Name + " : I" + m.Name + "\n";
			code += "{\n";
			code += Indent (properties);
			code += "\n";
			foreach (Message sub in m.Messages) {
				code += Indent (GenerateClass (sub));
				code += "\n";
			}
			code += "}\n";
			return code;
		}
		
		static string GenerateClassBackend (Message m)
		{
			//Enums
			string enums = "";
			foreach (MessageEnum me in m.Enums) {
				enums += "public enum " + me.Name + "\n";
				enums += "{\n";
				foreach (var epair in me.Enums)
					enums += "	" + epair.Key + " = " + epair.Value + ",\n";
				enums += "}\n";
			}
			
			//Constructor with default values
			string constructor = "public " + m.Name + "()\n";
			constructor += "{\n";
			foreach (Field f in m.Fields) {
				if (f.Rule == Rules.Repeated)
					constructor += "	this." + f.Name + " = new " + f.CSType + "();\n";
				else if (f.Default != null)
					constructor += "	this." + f.Name + " = " + f.Default + ";\n";
				else if (f.Rule == Rules.Optional) {
					if (f.ProtoType == ProtoTypes.Enum) {
						//the default value is the first value listed in the enum's type definition
						foreach (var kvp in f.ProtoTypeEnum.Enums) {
							constructor += "	this." + f.Name + " = " + kvp.Key + ";\n";
							break;
						}
					}
					if (f.ProtoType == ProtoTypes.String) {
						constructor += "	this." + f.Name + " = \"\";\n";
					}
				}
			}
			constructor += "}\n";

			//Default class
			string code = "";
			code += GenerateInterface (m);
			code += "\n";
			code += "public partial class " + m.Name + " : I" + m.Name + "\n";
			code += "{\n";
			code += Indent (enums);
			code += "\n";
			foreach (Message sub in m.Messages) {
				code += Indent (GenerateClassBackend (sub));
				code += "\n";
			}
			code += Indent (constructor);
			code += "\n";
			code += Indent (GenerateReader (m));
			code += "\n";
			code += Indent (GenerateWriter (m));
			code += "}\n";
			return code;
		}
		
		#region Protocol Reader
		
		static string GenerateReader (Message m)
		{
			string code = "";
			code += "public static " + m.Name + " Read(Stream stream)\n";
			code += "{\n";
			code += "	" + m.Name + " instance = new " + m.Name + "();\n";
			code += "	Read(stream, instance);\n";
			code += "	return instance;\n";
			code += "}\n";
			code += "\n";
			code += "public static " + m.Name + " Read(byte[] buffer)\n";
			code += "{\n";
			code += "	using(MemoryStream ms = new MemoryStream(buffer))\n";
			code += "		return Read(ms);\n";
			code += "}\n";
			code += "\n";
			code += "public static I" + m.Name + " Read(byte[] buffer, I" + m.Name + " instance)\n";
			code += "{\n";
			code += "	using(MemoryStream ms = new MemoryStream(buffer))\n";
			code += "		return Read(ms, instance);\n";
			code += "}\n";
			code += "\n";
			code += "public static I" + m.Name + " Read (Stream stream, I" + m.Name + " instance)\n";
			code += "{\n";
			foreach (Field f in m.Fields) {
				if (f.WireType == Wire.Fixed32 || f.WireType == Wire.Fixed64) {
					code += "	BinaryReader br = new BinaryReader (stream);";
					break;
				}
			}
			code += "	while (true)\n";
			code += "	{\n";
			code += "		Key key = null;\n";
			code += "		try {\n";
			code += "			key = ProtocolParser.ReadKey (stream);\n";
			code += "		} catch (InvalidDataException) {\n";
			code += "			break;\n";
			code += "		}\n";
			code += "\n";
			code += "		switch (key.Field) {\n";
			foreach (Field f in m.Fields) {
				code += "		case " + f.ID + ":\n";
				code += Indent (3, GenerateFieldReader (f)) + "\n";
				code += "			break;\n";
			}
			code += "		default:\n";
			code += "			ProtocolParser.SkipKey(stream, key);\n";
			code += "			break;\n";
			code += "		}\n";
			code += "	}\n";
			code += "	return instance;\n";
			code += "}\n";
			return code;
		}

		static string GenerateFieldReader (Field f)
		{
			string code = "";
			if (f.Rule == Rules.Repeated) {
				if (f.Packed == true) {
					code += "using(MemoryStream ms" + f.ID + " = new MemoryStream(ProtocolParser.ReadBytes(stream)))\n";
					code += "{\n";
					code += "	while(true)\n";
					code += "	{\n";
					code += "		if(ms" + f.ID + ".Position == ms" + f.ID + ".Length)\n";
					code += "			break;\n";
					code += "		instance." + f.Name + ".Add(" + GenerateFieldTypeReader (f, "ms" + f.ID, "br", null) + ");\n";
					code += "	}\n";
					code += "}\n";
				} else {
					code += "instance." + f.Name + ".Add(" + GenerateFieldTypeReader (f, "stream", "br", null) + ");";
				}
			} else {			
				if (f.ProtoType == ProtoTypes.Message) {
					code += "if(instance." + f.Name + " == null)\n";
					code += "	instance." + f.Name + " = new " + f.CSClass + "();\n";
				}
				code += "instance." + f.Name + " = " + GenerateFieldTypeReader (f, "stream", "br", "instance." + f.Name) + ";";
			}
			return code;
		}

		static string GenerateFieldTypeReader (Field f, string stream, string binaryReader, string instance)
		{
			switch (f.ProtoType) {
			case ProtoTypes.Double:
				return "br.ReadDouble ()";
			case ProtoTypes.Float:
				return "br.ReadSingle ()";
			case ProtoTypes.Fixed32:
				return "br.ReadUInt32 ()";
			case ProtoTypes.Fixed64:
				return "br.ReadUInt64 ()";
			case ProtoTypes.Sfixed32:
				return "br.ReadInt32 ()";
			case ProtoTypes.Sfixed64:
				return "br.ReadInt64 ()";
			case ProtoTypes.Int32:
				return "(int)ProtocolParser.ReadUInt32(" + stream + ")";
			case ProtoTypes.Int64:
				return "(long)ProtocolParser.ReadUInt64(" + stream + ")";
			case ProtoTypes.Uint32:
				return "ProtocolParser.ReadUInt32(" + stream + ")";
			case ProtoTypes.Uint64:
				return "ProtocolParser.ReadUInt64(" + stream + ");";
			case ProtoTypes.Sint32:
				return "ProtocolParser.ReadSInt32(" + stream + ");";
			case ProtoTypes.Sint64:
				return "ProtocolParser.ReadSInt64(" + stream + ");";
			case ProtoTypes.Bool:
				return "ProtocolParser.ReadBool(" + stream + ")";
			case ProtoTypes.String:
				return "ProtocolParser.ReadString(" + stream + ")";
			case ProtoTypes.Bytes:
				return "ProtocolParser.ReadBytes(" + stream + ")";
			case ProtoTypes.Enum:
				return "(" + f.CSItemType + ")ProtocolParser.ReadUInt32(" + stream + ")";
			case ProtoTypes.Message:				
				if (f.Rule == Rules.Repeated)
					return f.CSClass + ".Read(ProtocolParser.ReadBytes(" + stream + "))";
				else
					return f.CSClass + ".Read(ProtocolParser.ReadBytes(" + stream + "), " + instance + ")";
			default:
				throw new NotImplementedException ();
			}
		}

		#endregion
		
		#region Protocol Writer
		
		/// <summary>
		/// Generates code for writing a class/message
		/// </summary>
		static string GenerateWriter (Message m)
		{
			string code = "public static void Write(Stream stream, I" + m.Name + " instance)\n";
			code += "{\n";
			if (GenerateBinaryWriter (m))
				code += "	BinaryWriter bw = new BinaryWriter(stream);\n";
			
			foreach (Field f in m.Fields) {
				code += Indent (GenerateFieldWriter (m, f));
			}
			code += "}\n";
			return code;
		}
		
		/// <summary>
		/// Adds BinaryWriter only if it will be used
		/// </summary>
		static bool GenerateBinaryWriter (Message m)
		{
			foreach (Field f in m.Fields) {
				if (f.WireType == Wire.Fixed32 || f.WireType == Wire.Fixed64) {
					return true;
				}
			}
			return false;
		}
		
		/// <summary>
		/// Generates code for writing one field
		/// </summary>
		static string GenerateFieldWriter (Message m, Field f)
		{
			string code = "";
			if (f.Rule == Rules.Repeated) {
				if (f.Packed == true) {
					
					string binaryWriter = "";
					switch (f.ProtoType) {
					case ProtoTypes.Double:
					case ProtoTypes.Float:
					case ProtoTypes.Fixed32:
					case ProtoTypes.Fixed64:
					case ProtoTypes.Sfixed32:
					case ProtoTypes.Sfixed64:
						binaryWriter = "\nBinaryWriter bw" + f.ID + " = new BinaryWriter(ms" + f.ID + ");";
						break;
					}
					
					code += "ProtocolParser.WriteKey(stream, new Key(" + f.ID + ", Wire." + f.WireType + "));\n";
					code += "using(MemoryStream ms" + f.ID + " = new MemoryStream())\n";
					code += "{	" + binaryWriter + "\n";
					code += "	foreach (" + f.CSItemType + " i" + f.ID + " in instance." + f.Name + ")\n";
					code += "	{\n";
					code += "" + Indent (2, GenerateFieldTypeWriter (f, "ms" + f.ID, "bw" + f.ID, "i" + f.ID)) + "\n";
					code += "	}\n";
					code += "	ProtocolParser.WriteBytes(stream, ms" + f.ID + ".ToArray());\n";
					code += "}\n";
					return code;
				} else {
					code += "foreach (" + f.CSItemType + " i" + f.ID + " in instance." + f.Name + ")\n";
					code += "{\n";
					code += "	ProtocolParser.WriteKey(stream, new Key(" + f.ID + ", Wire." + f.WireType + "));\n";
					code += "" + Indent (1, GenerateFieldTypeWriter (f, "stream", "bw", "i" + f.ID)) + "\n";
					code += "}\n";
					return code;
				}
			} else if (f.Rule == Rules.Optional) {			
				switch (f.ProtoType) {
				case ProtoTypes.String:
				case ProtoTypes.Message:
				case ProtoTypes.Bytes:
					code += "if(instance." + f.Name + " != null)\n";
					code += "{\n";
					code += "	ProtocolParser.WriteKey(stream, new Key(" + f.ID + ", Wire." + f.WireType + "));\n";
					code += Indent (GenerateFieldTypeWriter (f, "stream", "bw", "instance." + f.Name));
					code += "}\n";
					return code;
				case ProtoTypes.Enum:
					code += "if(instance." + f.Name + " != " + f.Default + ")\n";
					code += "{\n";
					code += "	ProtocolParser.WriteKey(stream, new Key(" + f.ID + ", Wire." + f.WireType + "));\n";
					code += Indent (GenerateFieldTypeWriter (f, "stream", "bw", "instance." + f.Name));
					code += "}\n";
					return code;
				default:
					code += "ProtocolParser.WriteKey(stream, new Key(" + f.ID + ", Wire." + f.WireType + "));\n";
					code += GenerateFieldTypeWriter (f, "stream", "bw", "instance." + f.Name);
					return code;
				}
			} else if (f.Rule == Rules.Required) {			
				switch (f.ProtoType) {
				case ProtoTypes.String:
				case ProtoTypes.Message:
				case ProtoTypes.Bytes:
					code += "if(instance." + f.Name + " == null)\n";
					code += "	throw new ArgumentNullException(\"" + f.Name + "\", \"Required by proto specification.\");\n";
					break;
				}
				code += "ProtocolParser.WriteKey(stream, new Key(" + f.ID + ", Wire." + f.WireType + "));\n";
				code += GenerateFieldTypeWriter (f, "stream", "bw", "instance." + f.Name);
				return code;
			}			
			throw new NotImplementedException ("Unknown rule: " + f.Rule);
		}
					
		static string GenerateFieldTypeWriter (Field f, string stream, string binaryWriter, string instance)
		{
			switch (f.ProtoType) {
			case ProtoTypes.Double:
			case ProtoTypes.Float:
			case ProtoTypes.Fixed32:
			case ProtoTypes.Fixed64:
			case ProtoTypes.Sfixed32:
			case ProtoTypes.Sfixed64:
				return binaryWriter + ".Write(" + instance + ");\n";
			case ProtoTypes.Int32:
				return "ProtocolParser.WriteUInt32(" + stream + ", (uint)" + instance + ");\n";
			case ProtoTypes.Int64:
				return "ProtocolParser.WriteUInt64(" + stream + ", (ulong)" + instance + ");\n";
			case ProtoTypes.Uint32:
				return "ProtocolParser.WriteUInt32(" + stream + ", " + instance + ");\n";
			case ProtoTypes.Uint64:
				return "ProtocolParser.WriteUInt64(" + stream + ", " + instance + ");\n";
			case ProtoTypes.Sint32:
				return "ProtocolParser.WriteSInt32(" + stream + ", " + instance + ");\n";
			case ProtoTypes.Sint64:
				return "ProtocolParser.WriteSInt64(" + stream + ", " + instance + ");\n";
			case ProtoTypes.Bool:
				return "ProtocolParser.WriteBool(" + stream + ", " + instance + ");\n";
			case ProtoTypes.String:
				return "ProtocolParser.WriteString(" + stream + ", " + instance + ");\n";
			case ProtoTypes.Bytes:
				return "ProtocolParser.WriteBytes(" + stream + ", " + instance + ");\n";
			case ProtoTypes.Enum:
				return "ProtocolParser.WriteUInt32(" + stream + ", (uint)" + instance + ");\n";
			case ProtoTypes.Message:				
				string code = "";
				code += "using(MemoryStream ms" + f.ID + " = new MemoryStream())\n";
				code += "{\n";
				code += "	" + f.CSClass + ".Write(ms" + f.ID + ", " + instance + ");\n";
				code += "	ProtocolParser.WriteBytes(" + stream + ", ms" + f.ID + ".ToArray());\n";
				code += "}\n";
				return code;
			default:
				throw new NotImplementedException ();
			}
		}
		
		#endregion
	
		/// <summary>
		/// Indent all lines in the code string with one tab
		/// </summary>
		private static string Indent (string code)
		{
			return Indent (1, code);
		}
		
		/// <summary>
		/// Indent all lines in the code string with given number of tabs
		/// </summary>
		private static string Indent (int tabs, string code)
		{
			string sep = "\n";
			for (int n = 0; n < tabs; n++)
				sep += "\t";
			code = sep + string.Join (sep, code.Split ('\n'));
			return code.Substring (1).TrimEnd ('\t');			
		}
		
	}
}

