// Classes and structures being serialized

// Generated by ProtocolBuffer
// - a pure c# code generation implementation of protocol buffers
// Report bugs to: https://silentorbit.com/protobuf/

// DO NOT EDIT
// This file will be overwritten when CodeGenerator is run.
// To make custom modifications, edit the .proto file and add //:external before the message line
// then write the code and the changes in a separate file.
using System;
using System.Collections.Generic;

namespace Personal
{
    public partial class Person
    {
        public enum PhoneType
        {
            MOBILE = 0,
            HOME = 1,
            WORK = 2,
        }

        public string Name { get; set; }

        public int Id { get; set; }

        public string Email { get; set; }

        public List<Personal.Person.PhoneNumber> Phone { get; set; }

        public partial class PhoneNumber
        {
            public PhoneNumber()
            {
                Type = Personal.Person.PhoneType.HOME;
            }
            public string Number { get; set; }

            public Personal.Person.PhoneType Type { get; set; }

        }

    }

    public partial class AddressBook
    {
        public List<Personal.Person> List { get; set; }

    }

}
namespace Google.Protobuf
{
    /// <summary>
    /// <para> The protocol compiler can output a FileDescriptorSet containing the .proto</para>
    /// <para> files it parses.</para>
    /// </summary>
    public partial class FileDescriptorSet
    {
        public List<Google.Protobuf.FileDescriptorProto> File { get; set; }

    }

    /// <summary> Describes a complete .proto file.</summary>
    public partial class FileDescriptorProto
    {
        public string Name { get; set; }

        /// <summary> file name, relative to root of source tree</summary>
        public string Package { get; set; }

        /// <summary>
        /// <para> e.g. "foo", "foo.bar", etc.</para>
        /// <para> Names of files imported by this file.</para>
        /// </summary>
        public List<string> Dependency { get; set; }

        /// <summary> Indexes of the public imported files in the dependency list above.</summary>
        public List<int> PublicDependency { get; set; }

        /// <summary>
        /// <para> Indexes of the weak imported files in the dependency list.</para>
        /// <para> For Google-internal migration only. Do not use.</para>
        /// </summary>
        public List<int> WeakDependency { get; set; }

        /// <summary> All top-level definitions in this file.</summary>
        public List<Google.Protobuf.DescriptorProto> MessageType { get; set; }

        public List<Google.Protobuf.EnumDescriptorProto> EnumType { get; set; }

        public List<Google.Protobuf.ServiceDescriptorProto> Service { get; set; }

        public List<Google.Protobuf.FieldDescriptorProto> Extension { get; set; }

        public Google.Protobuf.FileOptions Options { get; set; }

        /// <summary>
        /// <para> This field contains optional information about the original source code.</para>
        /// <para> You may safely remove this entire field whithout harming runtime</para>
        /// <para> functionality of the descriptors -- the information is needed only by</para>
        /// <para> development tools.</para>
        /// </summary>
        public Google.Protobuf.SourceCodeInfo SourceCodeInfo { get; set; }

    }

    /// <summary> Describes a message type.</summary>
    public partial class DescriptorProto
    {
        public string Name { get; set; }

        public List<Google.Protobuf.FieldDescriptorProto> Field { get; set; }

        public List<Google.Protobuf.FieldDescriptorProto> Extension { get; set; }

        public List<Google.Protobuf.DescriptorProto> NestedType { get; set; }

        public List<Google.Protobuf.EnumDescriptorProto> EnumType { get; set; }

        public List<Google.Protobuf.DescriptorProto.ExtensionRange> ExtensionRangeField { get; set; }

        public Google.Protobuf.MessageOptions Options { get; set; }

        public partial class ExtensionRange
        {
            public int Start { get; set; }

            public int End { get; set; }

        }

    }

    /// <summary> Describes a field within a message.</summary>
    public partial class FieldDescriptorProto
    {
        public enum Type
        {
            /// <summary>
            /// <para> 0 is reserved for errors.</para>
            /// <para> Order is weird for historical reasons.</para>
            /// </summary>
            TYPE_DOUBLE = 1,
            TYPE_FLOAT = 2,
            /// <summary>
            /// <para> Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if</para>
            /// <para> negative values are likely.</para>
            /// </summary>
            TYPE_INT64 = 3,
            TYPE_UINT64 = 4,
            /// <summary>
            /// <para> Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if</para>
            /// <para> negative values are likely.</para>
            /// </summary>
            TYPE_INT32 = 5,
            TYPE_FIXED64 = 6,
            TYPE_FIXED32 = 7,
            TYPE_BOOL = 8,
            TYPE_STRING = 9,
            TYPE_GROUP = 10,
            /// <summary> Tag-delimited aggregate.</summary>
            TYPE_MESSAGE = 11,
            /// <summary>
            /// <para> Length-delimited aggregate.</para>
            /// <para> New in version 2.</para>
            /// </summary>
            TYPE_BYTES = 12,
            TYPE_UINT32 = 13,
            TYPE_ENUM = 14,
            TYPE_SFIXED32 = 15,
            TYPE_SFIXED64 = 16,
            TYPE_SINT32 = 17,
            /// <summary> Uses ZigZag encoding.</summary>
            TYPE_SINT64 = 18,
        }

        public enum Label
        {
            /// <summary> 0 is reserved for errors</summary>
            LABEL_OPTIONAL = 1,
            LABEL_REQUIRED = 2,
            LABEL_REPEATED = 3,
        }

        public string Name { get; set; }

        public int Number { get; set; }

        public Google.Protobuf.FieldDescriptorProto.Label label { get; set; }

        /// <summary>
        /// <para> If type_name is set, this need not be set.  If both this and type_name</para>
        /// <para> are set, this must be either TYPE_ENUM or TYPE_MESSAGE.</para>
        /// </summary>
        public Google.Protobuf.FieldDescriptorProto.Type type { get; set; }

        /// <summary>
        /// <para> For message and enum types, this is the name of the type.  If the name</para>
        /// <para> starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping</para>
        /// <para> rules are used to find the type (i.e. first the nested types within this</para>
        /// <para> message are searched, then within the parent, on up to the root</para>
        /// <para> namespace).</para>
        /// </summary>
        public string TypeName { get; set; }

        /// <summary>
        /// <para> For extensions, this is the name of the type being extended.  It is</para>
        /// <para> resolved in the same manner as type_name.</para>
        /// </summary>
        public string Extendee { get; set; }

        /// <summary>
        /// <para> For numeric types, contains the original text representation of the value.</para>
        /// <para> For booleans, "true" or "false".</para>
        /// <para> For strings, contains the default text contents (not escaped in any way).</para>
        /// <para> For bytes, contains the C escaped value.  All bytes >= 128 are escaped.</para>
        /// <para> TODO(kenton):  Base-64 encode?</para>
        /// </summary>
        public string DefaultValue { get; set; }

        public Google.Protobuf.FieldOptions Options { get; set; }

    }

    /// <summary> Describes an enum type.</summary>
    public partial class EnumDescriptorProto
    {
        public string Name { get; set; }

        public List<Google.Protobuf.EnumValueDescriptorProto> Value { get; set; }

        public Google.Protobuf.EnumOptions Options { get; set; }

    }

    /// <summary> Describes a value within an enum.</summary>
    public partial class EnumValueDescriptorProto
    {
        public string Name { get; set; }

        public int Number { get; set; }

        public Google.Protobuf.EnumValueOptions Options { get; set; }

    }

    /// <summary> Describes a service.</summary>
    public partial class ServiceDescriptorProto
    {
        public string Name { get; set; }

        public List<Google.Protobuf.MethodDescriptorProto> Method { get; set; }

        public Google.Protobuf.ServiceOptions Options { get; set; }

    }

    /// <summary> Describes a method of a service.</summary>
    public partial class MethodDescriptorProto
    {
        public string Name { get; set; }

        /// <summary>
        /// <para> Input and output type names.  These are resolved in the same way as</para>
        /// <para> FieldDescriptorProto.type_name, but must refer to a message type.</para>
        /// </summary>
        public string InputType { get; set; }

        public string OutputType { get; set; }

        public Google.Protobuf.MethodOptions Options { get; set; }

    }

    /// <summary>
    /// <para> ===================================================================</para>
    /// <para> Options</para>
    /// <para> Each of the definitions above may have "options" attached.  These are</para>
    /// <para> just annotations which may cause code to be generated slightly differently</para>
    /// <para> or may contain hints for code that manipulates protocol messages.</para>
    /// <para></para>
    /// <para> Clients may define custom options as extensions of the *Options messages.</para>
    /// <para> These extensions may not yet be known at parsing time, so the parser cannot</para>
    /// <para> store the values in them.  Instead it stores them in a field in the *Options</para>
    /// <para> message called uninterpreted_option. This field must have the same name</para>
    /// <para> across all *Options messages. We then use this field to populate the</para>
    /// <para> extensions when we build a descriptor, at which point all protos have been</para>
    /// <para> parsed and so all extensions are known.</para>
    /// <para></para>
    /// <para> Extension numbers for custom options may be chosen as follows:</para>
    /// <para> * For options which will only be used within a single application or</para>
    /// <para>   organization, or for experimental options, use field numbers 50000</para>
    /// <para>   through 99999.  It is up to you to ensure that you do not use the</para>
    /// <para>   same number for multiple options.</para>
    /// <para> * For options which will be published and used publicly by multiple</para>
    /// <para>   independent entities, e-mail protobuf-global-extension-registry@google.com</para>
    /// <para>   to reserve extension numbers. Simply provide your project name (e.g.</para>
    /// <para>   Object-C plugin) and your porject website (if available) -- there's no need</para>
    /// <para>   to explain how you intend to use them. Usually you only need one extension</para>
    /// <para>   number. You can declare multiple options with only one extension number by</para>
    /// <para>   putting them in a sub-message. See the Custom Options section of the docs</para>
    /// <para>   for examples:</para>
    /// <para>   http://code.google.com/apis/protocolbuffers/docs/proto.html#options</para>
    /// <para>   If this turns out to be popular, a web service will be set up</para>
    /// <para>   to automatically assign option numbers.</para>
    /// </summary>
    public partial class FileOptions
    {
        public FileOptions()
        {
            JavaMultipleFiles = false;
            JavaGenerateEqualsAndHash = false;
            OptimizeFor = Google.Protobuf.FileOptions.OptimizeMode.SPEED;
            CcGenericServices = false;
            JavaGenericServices = false;
            PyGenericServices = false;
        }
        /// <summary> Generated classes can be optimized for speed or code size.</summary>
        public enum OptimizeMode
        {
            SPEED = 1,
            /// <summary>
            /// <para> Generate complete code for parsing, serialization,</para>
            /// <para> etc.</para>
            /// </summary>
            CODE_SIZE = 2,
            /// <summary> Use ReflectionOps to implement these methods.</summary>
            LITE_RUNTIME = 3,
        }

        /// <summary>
        /// <para> Sets the Java package where classes generated from this .proto will be</para>
        /// <para> placed.  By default, the proto package is used, but this is often</para>
        /// <para> inappropriate because proto packages do not normally start with backwards</para>
        /// <para> domain names.</para>
        /// </summary>
        public string JavaPackage { get; set; }

        /// <summary>
        /// <para> If set, all the classes from the .proto file are wrapped in a single</para>
        /// <para> outer class with the given name.  This applies to both Proto1</para>
        /// <para> (equivalent to the old "--one_java_file" option) and Proto2 (where</para>
        /// <para> a .proto always translates to a single class, but you may want to</para>
        /// <para> explicitly choose the class name).</para>
        /// </summary>
        public string JavaOuterClassname { get; set; }

        /// <summary>
        /// <para> If set true, then the Java code generator will generate a separate .java</para>
        /// <para> file for each top-level message, enum, and service defined in the .proto</para>
        /// <para> file.  Thus, these types will *not* be nested inside the outer class</para>
        /// <para> named by java_outer_classname.  However, the outer class will still be</para>
        /// <para> generated to contain the file's getDescriptor() method as well as any</para>
        /// <para> top-level extensions defined in the file.</para>
        /// </summary>
        public bool JavaMultipleFiles { get; set; }

        /// <summary>
        /// <para> If set true, then the Java code generator will generate equals() and</para>
        /// <para> hashCode() methods for all messages defined in the .proto file. This is</para>
        /// <para> purely a speed optimization, as the AbstractMessage base class includes</para>
        /// <para> reflection-based implementations of these methods.</para>
        /// </summary>
        public bool JavaGenerateEqualsAndHash { get; set; }

        /// <summary> Generate code using MessageLite and the lite runtime.</summary>
        public Google.Protobuf.FileOptions.OptimizeMode OptimizeFor { get; set; }

        /// <summary>
        /// <para> Sets the Go package where structs generated from this .proto will be</para>
        /// <para> placed.  There is no default.</para>
        /// </summary>
        public string GoPackage { get; set; }

        /// <summary>
        /// <para> Should generic services be generated in each language?  "Generic" services</para>
        /// <para> are not specific to any particular RPC system.  They are generated by the</para>
        /// <para> main code generators in each language (without additional plugins).</para>
        /// <para> Generic services were the only kind of service generation supported by</para>
        /// <para> early versions of proto2.</para>
        /// <para></para>
        /// <para> Generic services are now considered deprecated in favor of using plugins</para>
        /// <para> that generate code specific to your particular RPC system.  Therefore,</para>
        /// <para> these default to false.  Old code which depends on generic services should</para>
        /// <para> explicitly set them to true.</para>
        /// </summary>
        public bool CcGenericServices { get; set; }

        public bool JavaGenericServices { get; set; }

        public bool PyGenericServices { get; set; }

        /// <summary> The parser stores options it doesn't recognize here. See above.</summary>
        public List<Google.Protobuf.UninterpretedOption> UninterpretedOption { get; set; }

    }

    public partial class MessageOptions
    {
        public MessageOptions()
        {
            MessageSetWireFormat = false;
            NoStandardDescriptorAccessor = false;
        }
        /// <summary>
        /// <para> Set true to use the old proto1 MessageSet wire format for extensions.</para>
        /// <para> This is provided for backwards-compatibility with the MessageSet wire</para>
        /// <para> format.  You should not use this for any other reason:  It's less</para>
        /// <para> efficient, has fewer features, and is more complicated.</para>
        /// <para></para>
        /// <para> The message must be defined exactly as follows:</para>
        /// <para>   message Foo {</para>
        /// <para>     option message_set_wire_format = true;</para>
        /// <para>     extensions 4 to max;</para>
        /// <para>   }</para>
        /// <para> Note that the message cannot have any defined fields; MessageSets only</para>
        /// <para> have extensions.</para>
        /// <para></para>
        /// <para> All extensions of your type must be singular messages; e.g. they cannot</para>
        /// <para> be int32s, enums, or repeated messages.</para>
        /// <para></para>
        /// <para> Because this is an option, the above two restrictions are not enforced by</para>
        /// <para> the protocol compiler.</para>
        /// </summary>
        public bool MessageSetWireFormat { get; set; }

        /// <summary>
        /// <para> Disables the generation of the standard "descriptor()" accessor, which can</para>
        /// <para> conflict with a field of the same name.  This is meant to make migration</para>
        /// <para> from proto1 easier; new code should avoid fields named "descriptor".</para>
        /// </summary>
        public bool NoStandardDescriptorAccessor { get; set; }

        /// <summary> The parser stores options it doesn't recognize here. See above.</summary>
        public List<Google.Protobuf.UninterpretedOption> UninterpretedOption { get; set; }

    }

    public partial class FieldOptions
    {
        public FieldOptions()
        {
            Ctype = Google.Protobuf.FieldOptions.CType.STRING;
            Lazy = false;
            Deprecated = false;
            Weak = false;
        }
        public enum CType
        {
            /// <summary> Default mode.</summary>
            STRING = 0,
            CORD = 1,
            STRING_PIECE = 2,
        }

        /// <summary>
        /// <para> The ctype option instructs the C++ code generator to use a different</para>
        /// <para> representation of the field than it normally would.  See the specific</para>
        /// <para> options below.  This option is not yet implemented in the open source</para>
        /// <para> release -- sorry, we'll try to include it in a future version!</para>
        /// </summary>
        public Google.Protobuf.FieldOptions.CType Ctype { get; set; }

        /// <summary>
        /// <para> The packed option can be enabled for repeated primitive fields to enable</para>
        /// <para> a more efficient representation on the wire. Rather than repeatedly</para>
        /// <para> writing the tag and type for each element, the entire array is encoded as</para>
        /// <para> a single length-delimited blob.</para>
        /// </summary>
        public bool Packed { get; set; }

        /// <summary>
        /// <para> Should this field be parsed lazily?  Lazy applies only to message-type</para>
        /// <para> fields.  It means that when the outer message is initially parsed, the</para>
        /// <para> inner message's contents will not be parsed but instead stored in encoded</para>
        /// <para> form.  The inner message will actually be parsed when it is first accessed.</para>
        /// <para></para>
        /// <para> This is only a hint.  Implementations are free to choose whether to use</para>
        /// <para> eager or lazy parsing regardless of the value of this option.  However,</para>
        /// <para> setting this option true suggests that the protocol author believes that</para>
        /// <para> using lazy parsing on this field is worth the additional bookkeeping</para>
        /// <para> overhead typically needed to implement it.</para>
        /// <para></para>
        /// <para> This option does not affect the public interface of any generated code;</para>
        /// <para> all method signatures remain the same.  Furthermore, thread-safety of the</para>
        /// <para> interface is not affected by this option; const methods remain safe to</para>
        /// <para> call from multiple threads concurrently, while non-const methods continue</para>
        /// <para> to require exclusive access.</para>
        /// <para></para>
        /// <para></para>
        /// <para> Note that implementations may choose not to check required fields within</para>
        /// <para> a lazy sub-message.  That is, calling IsInitialized() on the outher message</para>
        /// <para> may return true even if the inner message has missing required fields.</para>
        /// <para> This is necessary because otherwise the inner message would have to be</para>
        /// <para> parsed in order to perform the check, defeating the purpose of lazy</para>
        /// <para> parsing.  An implementation which chooses not to check required fields</para>
        /// <para> must be consistent about it.  That is, for any particular sub-message, the</para>
        /// <para> implementation must either *always* check its required fields, or *never*</para>
        /// <para> check its required fields, regardless of whether or not the message has</para>
        /// <para> been parsed.</para>
        /// </summary>
        public bool Lazy { get; set; }

        /// <summary>
        /// <para> Is this field deprecated?</para>
        /// <para> Depending on the target platform, this can emit Deprecated annotations</para>
        /// <para> for accessors, or it will be completely ignored; in the very least, this</para>
        /// <para> is a formalization for deprecating fields.</para>
        /// </summary>
        public bool Deprecated { get; set; }

        /// <summary>
        /// <para> EXPERIMENTAL.  DO NOT USE.</para>
        /// <para> For "map" fields, the name of the field in the enclosed type that</para>
        /// <para> is the key for this map.  For example, suppose we have:</para>
        /// <para>   message Item {</para>
        /// <para>     required string name = 1;</para>
        /// <para>     required string value = 2;</para>
        /// <para>   }</para>
        /// <para>   message Config {</para>
        /// <para>     repeated Item items = 1 [experimental_map_key="name"];</para>
        /// <para>   }</para>
        /// <para> In this situation, the map key for Item will be set to "name".</para>
        /// <para> TODO: Fully-implement this, then remove the "experimental_" prefix.</para>
        /// </summary>
        public string ExperimentalMapKey { get; set; }

        /// <summary> For Google-internal migration only. Do not use.</summary>
        public bool Weak { get; set; }

        /// <summary> The parser stores options it doesn't recognize here. See above.</summary>
        public List<Google.Protobuf.UninterpretedOption> UninterpretedOption { get; set; }

    }

    public partial class EnumOptions
    {
        public EnumOptions()
        {
            AllowAlias = true;
        }
        /// <summary>
        /// <para> Set this option to false to disallow mapping different tag names to a same</para>
        /// <para> value.</para>
        /// </summary>
        public bool AllowAlias { get; set; }

        /// <summary> The parser stores options it doesn't recognize here. See above.</summary>
        public List<Google.Protobuf.UninterpretedOption> UninterpretedOption { get; set; }

    }

    public partial class EnumValueOptions
    {
        /// <summary> The parser stores options it doesn't recognize here. See above.</summary>
        public List<Google.Protobuf.UninterpretedOption> UninterpretedOption { get; set; }

    }

    public partial class ServiceOptions
    {
        /// <summary>
        /// <para> Note:  Field numbers 1 through 32 are reserved for Google's internal RPC</para>
        /// <para>   framework.  We apologize for hoarding these numbers to ourselves, but</para>
        /// <para>   we were already using them long before we decided to release Protocol</para>
        /// <para>   Buffers.</para>
        /// <para> The parser stores options it doesn't recognize here. See above.</para>
        /// </summary>
        public List<Google.Protobuf.UninterpretedOption> UninterpretedOption { get; set; }

    }

    public partial class MethodOptions
    {
        /// <summary>
        /// <para> Note:  Field numbers 1 through 32 are reserved for Google's internal RPC</para>
        /// <para>   framework.  We apologize for hoarding these numbers to ourselves, but</para>
        /// <para>   we were already using them long before we decided to release Protocol</para>
        /// <para>   Buffers.</para>
        /// <para> The parser stores options it doesn't recognize here. See above.</para>
        /// </summary>
        public List<Google.Protobuf.UninterpretedOption> UninterpretedOption { get; set; }

    }

    /// <summary>
    /// <para> A message representing a option the parser does not recognize. This only</para>
    /// <para> appears in options protos created by the compiler::Parser class.</para>
    /// <para> DescriptorPool resolves these when building Descriptor objects. Therefore,</para>
    /// <para> options protos in descriptor objects (e.g. returned by Descriptor::options(),</para>
    /// <para> or produced by Descriptor::CopyTo()) will never have UninterpretedOptions</para>
    /// <para> in them.</para>
    /// </summary>
    public partial class UninterpretedOption
    {
        public List<Google.Protobuf.UninterpretedOption.NamePart> Name { get; set; }

        /// <summary>
        /// <para> The value of the uninterpreted option, in whatever type the tokenizer</para>
        /// <para> identified it as during parsing. Exactly one of these should be set.</para>
        /// </summary>
        public string IdentifierValue { get; set; }

        public ulong PositiveIntValue { get; set; }

        public long NegativeIntValue { get; set; }

        public double DoubleValue { get; set; }

        public byte[] StringValue { get; set; }

        public string AggregateValue { get; set; }

        /// <summary>
        /// <para> The name of the uninterpreted option.  Each string represents a segment in</para>
        /// <para> a dot-separated name.  is_extension is true iff a segment represents an</para>
        /// <para> extension (denoted with parentheses in options specs in .proto files).</para>
        /// <para> E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents</para>
        /// <para> "foo.(bar.baz).qux".</para>
        /// </summary>
        public partial class NamePart
        {
            public string NamePartField { get; set; }

            public bool IsExtension { get; set; }

        }

    }

    /// <summary>
    /// <para> ===================================================================</para>
    /// <para> Optional source code info</para>
    /// <para> Encapsulates information about the original source file from which a</para>
    /// <para> FileDescriptorProto was generated.</para>
    /// </summary>
    public partial class SourceCodeInfo
    {
        /// <summary>
        /// <para> A Location identifies a piece of source code in a .proto file which</para>
        /// <para> corresponds to a particular definition.  This information is intended</para>
        /// <para> to be useful to IDEs, code indexers, documentation generators, and similar</para>
        /// <para> tools.</para>
        /// <para></para>
        /// <para> For example, say we have a file like:</para>
        /// <para>   message Foo {</para>
        /// <para>     optional string foo = 1;</para>
        /// <para>   }</para>
        /// <para> Let's look at just the field definition:</para>
        /// <para>   optional string foo = 1;</para>
        /// <para>   ^       ^^     ^^  ^  ^^^</para>
        /// <para>   a       bc     de  f  ghi</para>
        /// <para> We have the following locations:</para>
        /// <para>   span   path               represents</para>
        /// <para>   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.</para>
        /// <para>   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).</para>
        /// <para>   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).</para>
        /// <para>   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).</para>
        /// <para>   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).</para>
        /// <para></para>
        /// <para> Notes:</para>
        /// <para> - A location may refer to a repeated field itself (i.e. not to any</para>
        /// <para>   particular index within it).  This is used whenever a set of elements are</para>
        /// <para>   logically enclosed in a single code segment.  For example, an entire</para>
        /// <para>   extend block (possibly containing multiple extension definitions) will</para>
        /// <para>   have an outer location whose path refers to the "extensions" repeated</para>
        /// <para>   field without an index.</para>
        /// <para> - Multiple locations may have the same path.  This happens when a single</para>
        /// <para>   logical declaration is spread out across multiple places.  The most</para>
        /// <para>   obvious example is the "extend" block again -- there may be multiple</para>
        /// <para>   extend blocks in the same scope, each of which will have the same path.</para>
        /// <para> - A location's span is not always a subset of its parent's span.  For</para>
        /// <para>   example, the "extendee" of an extension declaration appears at the</para>
        /// <para>   beginning of the "extend" block and is shared by all extensions within</para>
        /// <para>   the block.</para>
        /// <para> - Just because a location's span is a subset of some other location's span</para>
        /// <para>   does not mean that it is a descendent.  For example, a "group" defines</para>
        /// <para>   both a type and a field in a single declaration.  Thus, the locations</para>
        /// <para>   corresponding to the type and field and their components will overlap.</para>
        /// <para> - Code which tries to interpret locations should probably be designed to</para>
        /// <para>   ignore those that it doesn't understand, as more types of locations could</para>
        /// <para>   be recorded in the future.</para>
        /// </summary>
        public List<Google.Protobuf.SourceCodeInfo.Location> LocationField { get; set; }

        public partial class Location
        {
            /// <summary>
            /// <para> Identifies which part of the FileDescriptorProto was defined at this</para>
            /// <para> location.</para>
            /// <para></para>
            /// <para> Each element is a field number or an index.  They form a path from</para>
            /// <para> the root FileDescriptorProto to the place where the definition.  For</para>
            /// <para> example, this path:</para>
            /// <para>   [ 4, 3, 2, 7, 1 ]</para>
            /// <para> refers to:</para>
            /// <para>   file.message_type(3)  // 4, 3</para>
            /// <para>       .field(7)         // 2, 7</para>
            /// <para>       .name()           // 1</para>
            /// <para> This is because FileDescriptorProto.message_type has field number 4:</para>
            /// <para>   repeated DescriptorProto message_type = 4;</para>
            /// <para> and DescriptorProto.field has field number 2:</para>
            /// <para>   repeated FieldDescriptorProto field = 2;</para>
            /// <para> and FieldDescriptorProto.name has field number 1:</para>
            /// <para>   optional string name = 1;</para>
            /// <para></para>
            /// <para> Thus, the above path gives the location of a field name.  If we removed</para>
            /// <para> the last element:</para>
            /// <para>   [ 4, 3, 2, 7 ]</para>
            /// <para> this path refers to the whole field declaration (from the beginning</para>
            /// <para> of the label to the terminating semicolon).</para>
            /// </summary>
            public List<int> Path { get; set; }

            /// <summary>
            /// <para> Always has exactly three or four elements: start line, start column,</para>
            /// <para> end line (optional, otherwise assumed same as start line), end column.</para>
            /// <para> These are packed into a single field for efficiency.  Note that line</para>
            /// <para> and column numbers are zero-based -- typically you will want to add</para>
            /// <para> 1 to each before displaying to a user.</para>
            /// </summary>
            public List<int> Span { get; set; }

            /// <summary>
            /// <para> If this SourceCodeInfo represents a complete declaration, these are any</para>
            /// <para> comments appearing before and after the declaration which appear to be</para>
            /// <para> attached to the declaration.</para>
            /// <para></para>
            /// <para> A series of line comments appearing on consecutive lines, with no other</para>
            /// <para> tokens appearing on those lines, will be treated as a single comment.</para>
            /// <para></para>
            /// <para> Only the comment content is provided; comment markers (e.g. //) are</para>
            /// <para> stripped out.  For block comments, leading whitespace and an asterisk</para>
            /// <para> will be stripped from the beginning of each line other than the first.</para>
            /// <para> Newlines are included in the output.</para>
            /// <para></para>
            /// <para> Examples:</para>
            /// <para></para>
            /// <para>   optional int32 foo = 1;  // Comment attached to foo.</para>
            /// <para>   // Comment attached to bar.</para>
            /// <para>   optional int32 bar = 2;</para>
            /// <para></para>
            /// <para>   optional string baz = 3;</para>
            /// <para>   // Comment attached to baz.</para>
            /// <para>   // Another line attached to baz.</para>
            /// <para></para>
            /// <para>   // Comment attached to qux.</para>
            /// <para>   //</para>
            /// <para>   // Another line attached to qux.</para>
            /// <para>   optional double qux = 4;</para>
            /// <para></para>
            /// <para>   optional string corge = 5;</para>
            /// <para>   /* Block comment attached</para>
            /// <para>    * to corge.  Leading asterisks</para>
            /// <para>    * will be removed. */</para>
            /// <para>   /* Block comment attached to</para>
            /// <para>    * grault. */</para>
            /// <para>   optional int32 grault = 6;</para>
            /// </summary>
            public string LeadingComments { get; set; }

            public string TrailingComments { get; set; }

        }

    }

}
namespace Local
{
    /// <summary>This is a demonstration of features only present in ProtoBuf Code Generator</summary>
    internal partial class LocalFeatures
    {
        /// <summary>Make class field of type TimeSpan, serialized to Ticks</summary>
        public TimeSpan Uptime { get; set; }

        /// <summary>Make class field of type DateTime, serialized to Ticks</summary>
        public DateTime DueDate { get; set; }

        /// <summary>Do not generate class field, must be implemented in other partial class</summary>
        //public double Amount { get; set; } // Implemented by user elsewhere

        /// <summary>Custom field access types. Default: public</summary>
        private string Denial { get; set; }

        protected string Secret { get; set; }

        internal string Internal { get; set; }

        public string PR { get; set; }

        /// <summary>Generate a c# readonly field</summary>
        public readonly Mine.MyMessageV1 TestingReadOnly = new Mine.MyMessageV1();

        /// <summary>When deserializing this one must be set to a class before</summary>
        public LocalFeatureTest.InterfaceTest MyInterface { get; set; }

        public LocalFeatureTest.StructTest MyStruct;

        public TestB.ExternalStruct MyExtStruct;

        public TestB.ExternalClass MyExtClass { get; set; }

        public LocalFeatureTest.TopEnum MyEnum { get; set; }

        // protected virtual void BeforeSerialize() {}
        // protected virtual void AfterDeserialize() {}

    }

}
namespace LocalFeatureTest
{
    /// <summary>Testing local struct serialization</summary>
    public partial interface InterfaceTest
    {
    }

    /// <summary>Testing local struct serialization</summary>
    public partial struct StructTest
    {
    }

}
namespace TestB
{
    // Written elsewhere
    // public struct ExternalStruct {}

    // Written elsewhere
    // public class ExternalClass {}

}
namespace Mine
{
    /// <summary>
    /// <para>This class is documented here:</para>
    /// <para>With multiple lines</para>
    /// </summary>
    public partial class MyMessageV1
    {
        /// <summary>This field is important to comment as we just did here</summary>
        public int FieldA { get; set; }

        /// <summary>Values for unknown fields.</summary>
        public List<global::SilentOrbit.ProtocolBuffers.KeyValue> PreservedFields;

    }

}
namespace Yours
{
    public partial class MyMessageV2
    {
        public MyMessageV2()
        {
            FieldA = -1;
            FieldB = 4.5;
            FieldC = 5.4f;
            FieldD = -2;
            FieldE = -3;
            FieldF = 4;
            FieldG = 5;
            FieldH = -6;
            FieldI = -7;
            FieldJ = 8;
            FieldK = 9;
            FieldL = -10;
            FieldM = -11;
            FieldN = false;
            FieldO = "test";
            FieldR = Yours.MyMessageV2.MyEnum.ETest2;
        }
        /// <summary>Adding some comments</summary>
        public enum MyEnum
        {
            /// <summary>First test</summary>
            ETest1 = 0,
            /// <summary>Second test</summary>
            ETest2 = 3,
            ETest3 = 2,
        }

        public enum AliasedEnum
        {
            Nothing = 0,
            Zero = 0,
            Nada = 0,
            Some = 1,
            ALot = 2,
        }

        public int FieldA { get; set; }

        public double FieldB { get; set; }

        public float FieldC { get; set; }

        public int FieldD { get; set; }

        public long FieldE { get; set; }

        public uint FieldF { get; set; }

        public ulong FieldG { get; set; }

        public int FieldH { get; set; }

        public long FieldI { get; set; }

        public uint FieldJ { get; set; }

        public ulong FieldK { get; set; }

        public int FieldL { get; set; }

        public long FieldM { get; set; }

        public bool FieldN { get; set; }

        public string FieldO { get; set; }

        [Obsolete]
        public byte[] FieldP { get; set; }

        public Yours.MyMessageV2.MyEnum FieldQ { get; set; }

        public Yours.MyMessageV2.MyEnum FieldR { get; set; }

        [Obsolete]
        protected string Dummy { get; set; }

        public List<uint> FieldT { get; set; }

        public List<uint> FieldS { get; set; }

        public Theirs.TheirMessage FieldU { get; set; }

        public List<Theirs.TheirMessage> FieldV { get; set; }

        public int NullableInt { get; set; }

        public Yours.MyMessageV2.AliasedEnum NullableEnum { get; set; }

    }

}
namespace Theirs
{
    public partial class TheirMessage
    {
        public int FieldA { get; set; }

    }

}
namespace Proto.Test
{
    /// <summary>Message without any low id(< 16) fields</summary>
    public partial class LongMessage
    {
        public int FieldX1 { get; set; }

        public int FieldX2 { get; set; }

        public int FieldX3 { get; set; }

        public int FieldX4 { get; set; }

    }

    /// <summary>Nested testing</summary>
    public partial class Data
    {
        public double Somefield { get; set; }

    }

    public partial class Container
    {
        public Proto.Test.Container.Nested MyNestedMessage { get; set; }

        /// <summary>Name collision test</summary>
        public Proto.Test.Container.Nested NestedField { get; set; }

        public partial class Nested
        {
            public Proto.Test.Data NestedData { get; set; }

        }

    }

    public partial class MyMessage
    {
        public int Foo { get; set; }

        public string Bar { get; set; }

    }

}
namespace LocalFeatureTest
{
    [global::System.FlagsAttribute]
    public enum TopEnum
    {
        First = 1,
        Last = 1000000,
    }


    // Written elsewhere
    //
    // public enum ExternalEnum
    // {
    //     First = 1,
    //     Last = 1000000,
    // }

}
namespace Proto.Test
{
    public enum MyEnum
    {
        FOO = 1,
        BAR = 2,
    }


}
